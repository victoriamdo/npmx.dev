import { describe, expect, it, vi, beforeEach } from 'vitest'

// Mock Nitro globals before importing the module
vi.stubGlobal('defineCachedFunction', (fn: Function) => fn)
vi.stubGlobal('$fetch', vi.fn())

// Import module under test
const { analyzeVulnerabilityTree } = await import('../../server/utils/vulnerability-tree')

// Mock the dependency resolver
vi.mock('../../server/utils/dependency-resolver', () => ({
  resolveDependencyTree: vi.fn(),
}))

const { resolveDependencyTree } = await import('../../server/utils/dependency-resolver')

describe('vulnerability-tree', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('analyzeVulnerabilityTree', () => {
    it('returns empty result when no packages have vulnerabilities', async () => {
      const mockResolved = new Map([
        [
          'test-pkg@1.0.0',
          {
            name: 'test-pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['test-pkg@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      // Mock OSV API returning no vulnerabilities
      vi.mocked($fetch).mockResolvedValue({ vulns: [] })

      const result = await analyzeVulnerabilityTree('test-pkg', '1.0.0')

      expect(result.package).toBe('test-pkg')
      expect(result.version).toBe('1.0.0')
      expect(result.vulnerablePackages).toHaveLength(0)
      expect(result.totalPackages).toBe(1)
      expect(result.failedQueries).toBe(0)
      expect(result.totalCounts).toEqual({ total: 0, critical: 0, high: 0, moderate: 0, low: 0 })
    })

    it('tracks failed queries when OSV API fails', async () => {
      const mockResolved = new Map([
        [
          'test-pkg@1.0.0',
          {
            name: 'test-pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['test-pkg@1.0.0'],
          },
        ],
        [
          'dep-a@2.0.0',
          {
            name: 'dep-a',
            version: '2.0.0',
            size: 500,
            optional: false,
            depth: 'direct' as const,
            path: ['test-pkg@1.0.0', 'dep-a@2.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      // First call succeeds, second fails
      vi.mocked($fetch)
        .mockResolvedValueOnce({ vulns: [] })
        .mockRejectedValueOnce(new Error('OSV API error'))

      const result = await analyzeVulnerabilityTree('test-pkg', '1.0.0')

      expect(result.failedQueries).toBe(1)
      expect(result.totalPackages).toBe(2)
    })

    it('correctly counts vulnerabilities by severity', async () => {
      const mockResolved = new Map([
        [
          'vuln-pkg@1.0.0',
          {
            name: 'vuln-pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['vuln-pkg@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      // Mock OSV API returning vulnerabilities with different severities
      vi.mocked($fetch).mockResolvedValue({
        vulns: [
          { id: 'GHSA-1', summary: 'Critical vuln', database_specific: { severity: 'CRITICAL' } },
          { id: 'GHSA-2', summary: 'High vuln', database_specific: { severity: 'HIGH' } },
          { id: 'GHSA-3', summary: 'Moderate vuln', database_specific: { severity: 'MODERATE' } },
          { id: 'GHSA-4', summary: 'Low vuln', database_specific: { severity: 'LOW' } },
        ],
      })

      const result = await analyzeVulnerabilityTree('vuln-pkg', '1.0.0')

      expect(result.vulnerablePackages).toHaveLength(1)
      expect(result.totalCounts).toEqual({ total: 4, critical: 1, high: 1, moderate: 1, low: 1 })

      const pkg = result.vulnerablePackages[0]
      expect(pkg.counts.critical).toBe(1)
      expect(pkg.counts.high).toBe(1)
      expect(pkg.counts.moderate).toBe(1)
      expect(pkg.counts.low).toBe(1)
    })

    it('includes dependency path in vulnerable packages', async () => {
      const mockResolved = new Map([
        [
          'root@1.0.0',
          {
            name: 'root',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['root@1.0.0'],
          },
        ],
        [
          'vuln-dep@2.0.0',
          {
            name: 'vuln-dep',
            version: '2.0.0',
            size: 500,
            optional: false,
            depth: 'transitive' as const,
            path: ['root@1.0.0', 'middle@1.5.0', 'vuln-dep@2.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      vi.mocked($fetch)
        .mockResolvedValueOnce({ vulns: [] }) // root has no vulns
        .mockResolvedValueOnce({
          vulns: [
            { id: 'GHSA-test', summary: 'Test vuln', database_specific: { severity: 'HIGH' } },
          ],
        }) // vuln-dep has vuln

      const result = await analyzeVulnerabilityTree('root', '1.0.0')

      expect(result.vulnerablePackages).toHaveLength(1)
      const vulnPkg = result.vulnerablePackages[0]
      expect(vulnPkg.path).toEqual(['root@1.0.0', 'middle@1.5.0', 'vuln-dep@2.0.0'])
      expect(vulnPkg.depth).toBe('transitive')
    })

    it('sorts vulnerable packages by depth then severity', async () => {
      const mockResolved = new Map([
        [
          'root@1.0.0',
          {
            name: 'root',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['root@1.0.0'],
          },
        ],
        [
          'direct-dep@1.0.0',
          {
            name: 'direct-dep',
            version: '1.0.0',
            size: 500,
            optional: false,
            depth: 'direct' as const,
            path: ['root@1.0.0', 'direct-dep@1.0.0'],
          },
        ],
        [
          'transitive-dep@1.0.0',
          {
            name: 'transitive-dep',
            version: '1.0.0',
            size: 300,
            optional: false,
            depth: 'transitive' as const,
            path: ['root@1.0.0', 'direct-dep@1.0.0', 'transitive-dep@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      // All have vulnerabilities
      vi.mocked($fetch)
        .mockResolvedValueOnce({
          vulns: [
            { id: 'GHSA-root', summary: 'Root vuln', database_specific: { severity: 'LOW' } },
          ],
        })
        .mockResolvedValueOnce({
          vulns: [
            {
              id: 'GHSA-direct',
              summary: 'Direct vuln',
              database_specific: { severity: 'CRITICAL' },
            },
          ],
        })
        .mockResolvedValueOnce({
          vulns: [
            { id: 'GHSA-trans', summary: 'Trans vuln', database_specific: { severity: 'HIGH' } },
          ],
        })

      const result = await analyzeVulnerabilityTree('root', '1.0.0')

      expect(result.vulnerablePackages).toHaveLength(3)
      // Should be sorted: root first, then direct, then transitive
      expect(result.vulnerablePackages[0].name).toBe('root')
      expect(result.vulnerablePackages[1].name).toBe('direct-dep')
      expect(result.vulnerablePackages[2].name).toBe('transitive-dep')
    })

    it('generates correct vulnerability URLs for GHSA', async () => {
      const mockResolved = new Map([
        [
          'pkg@1.0.0',
          {
            name: 'pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['pkg@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      vi.mocked($fetch).mockResolvedValue({
        vulns: [
          {
            id: 'GHSA-xxxx-yyyy-zzzz',
            summary: 'Test vuln',
            database_specific: { severity: 'HIGH' },
          },
        ],
      })

      const result = await analyzeVulnerabilityTree('pkg', '1.0.0')

      expect(result.vulnerablePackages[0].vulnerabilities[0].url).toBe(
        'https://github.com/advisories/GHSA-xxxx-yyyy-zzzz',
      )
    })

    it('generates correct vulnerability URLs for CVE aliases', async () => {
      const mockResolved = new Map([
        [
          'pkg@1.0.0',
          {
            name: 'pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['pkg@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      vi.mocked($fetch).mockResolvedValue({
        vulns: [
          {
            id: 'OSV-2024-001',
            summary: 'Test vuln',
            aliases: ['CVE-2024-12345'],
            database_specific: { severity: 'HIGH' },
          },
        ],
      })

      const result = await analyzeVulnerabilityTree('pkg', '1.0.0')

      expect(result.vulnerablePackages[0].vulnerabilities[0].url).toBe(
        'https://nvd.nist.gov/vuln/detail/CVE-2024-12345',
      )
    })

    it('falls back to OSV URL for other vulnerability IDs', async () => {
      const mockResolved = new Map([
        [
          'pkg@1.0.0',
          {
            name: 'pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['pkg@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      vi.mocked($fetch).mockResolvedValue({
        vulns: [
          { id: 'PYSEC-2024-001', summary: 'Test vuln', database_specific: { severity: 'HIGH' } },
        ],
      })

      const result = await analyzeVulnerabilityTree('pkg', '1.0.0')

      expect(result.vulnerablePackages[0].vulnerabilities[0].url).toBe(
        'https://osv.dev/vulnerability/PYSEC-2024-001',
      )
    })

    it('extracts severity from CVSS score when database_specific is missing', async () => {
      const mockResolved = new Map([
        [
          'pkg@1.0.0',
          {
            name: 'pkg',
            version: '1.0.0',
            size: 1000,
            optional: false,
            depth: 'root' as const,
            path: ['pkg@1.0.0'],
          },
        ],
      ])
      vi.mocked(resolveDependencyTree).mockResolvedValue(mockResolved)

      vi.mocked($fetch).mockResolvedValue({
        vulns: [
          {
            id: 'GHSA-1',
            summary: 'Critical (9.5)',
            severity: [{ score: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/9.5' }],
          },
          { id: 'GHSA-2', summary: 'High (7.5)', severity: [{ score: '7.5' }] },
          { id: 'GHSA-3', summary: 'Moderate (5.0)', severity: [{ score: '5.0' }] },
          { id: 'GHSA-4', summary: 'Low (2.0)', severity: [{ score: '2.0' }] },
        ],
      })

      const result = await analyzeVulnerabilityTree('pkg', '1.0.0')

      expect(result.totalCounts.critical).toBe(1)
      expect(result.totalCounts.high).toBe(1)
      expect(result.totalCounts.moderate).toBe(1)
      expect(result.totalCounts.low).toBe(1)
    })
  })
})
